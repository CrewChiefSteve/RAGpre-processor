// This is your Prisma schema file
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:../dev.db"
}

model Job {
  id             String    @id @default(cuid())
  filename       String
  status         String    // "pending" | "running" | "completed" | "failed"
  documentType   String?

  // Config fields (flattened)
  chunkSize      Int       @default(800)
  chunkOverlap   Int       @default(150)
  maxPages       Int?
  enableTables   Boolean   @default(true)
  handwritingVision Boolean @default(false)
  captionDiagrams Boolean @default(false)
  debug          Boolean   @default(false)

  // Timestamps
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  startedAt      DateTime?
  completedAt    DateTime?

  // Error tracking
  error          String?

  // Phase statuses stored as JSON
  phasesJson     String    @default("{}")

  // Outputs stored as JSON (for Phase 2, we'll keep it simple)
  outputsJson    String    @default("{}")

  // File paths
  uploadedFilePath String?
  outputDir      String?

  // Relations
  logs           Log[]
  rulebooks      Rulebook[]
}

model Log {
  id        String   @id @default(cuid())
  jobId     String
  phase     String   // "A" | "B" | "C" | "D" | "system"
  level     String   // "info" | "warn" | "error"
  message   String
  createdAt DateTime @default(now())

  // Relations
  job       Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([phase])
}

model Settings {
  id              Int     @id @default(1)

  // Default job config
  chunkSize       Int     @default(800)
  chunkOverlap    Int     @default(150)
  maxPages        Int?
  enableTables    Boolean @default(true)
  handwritingVision Boolean @default(false)
  captionDiagrams Boolean @default(false)
  debug           Boolean @default(false)

  updatedAt       DateTime @updatedAt
}

// ============================================================================
// RAG Preprocessor V2: Rulebook Models
// ============================================================================

model Rulebook {
  id             String    @id @default(cuid())
  title          String
  series         String?   // e.g. "SVRA", "TA2"
  year           Int?
  version        String?
  sourceUrl      String?
  fileKey        String    // where the original PDF is stored (local path or blob key)
  pageCount      Int?

  ingestionJobId String?   // FK to Job
  ingestionJob   Job?      @relation(fields: [ingestionJobId], references: [id])

  sections       Section[]
  rules          Rule[]
  diagrams       Diagram[]
  tables         Table[]
  chunks         Chunk[]

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([ingestionJobId])
}

model Section {
  id             String     @id @default(cuid())
  rulebookId     String
  rulebook       Rulebook   @relation(fields: [rulebookId], references: [id], onDelete: Cascade)

  label          String?    // "3", "3.2", "3.2.4"
  title          String
  level          Int        // 1 = top-level, 2 = subsection, etc.
  pageStart      Int?
  pageEnd        Int?

  parentSectionId String?
  parentSection   Section?   @relation("SectionHierarchy", fields: [parentSectionId], references: [id], onDelete: SetNull)
  children        Section[]  @relation("SectionHierarchy")

  rules          Rule[]
  diagrams       Diagram[]
  tables         Table[]
  chunks         Chunk[]

  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  @@index([rulebookId])
  @@index([label, rulebookId])
  @@index([parentSectionId])
}

model Rule {
  id          String    @id @default(cuid())
  rulebookId  String
  rulebook    Rulebook  @relation(fields: [rulebookId], references: [id], onDelete: Cascade)

  sectionId   String?
  section     Section?  @relation(fields: [sectionId], references: [id], onDelete: SetNull)

  code        String    // "3.2.4"
  title       String?
  text        String    // normalized rule text
  pageStart   Int?
  pageEnd     Int?

  diagrams    Diagram[]
  tables      Table[]
  chunks      Chunk[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([rulebookId])
  @@index([code, rulebookId])
  @@index([sectionId])
}

model Diagram {
  id           String    @id @default(cuid())
  rulebookId   String
  rulebook     Rulebook  @relation(fields: [rulebookId], references: [id], onDelete: Cascade)

  sectionId    String?
  section      Section?  @relation(fields: [sectionId], references: [id], onDelete: SetNull)

  ruleId       String?
  rule         Rule?     @relation(fields: [ruleId], references: [id], onDelete: SetNull)

  page         Int?
  // normalized 0â€“1 coords in JSON, e.g. { x, y, width, height }
  boundingBox  String?   // JSON as String for SQLite

  imageKey     String    // "rulebooks/{rulebookId}/diagrams/{page}-{index}.png"
  publicUrl    String?   // public URL after upload

  caption      String?   // short summary
  explanation  String?   // longer AI-generated explanation
  tags         String?   // JSON array of strings as String for SQLite
  refersToRuleCode String?

  chunks       Chunk[]   // e.g. diagram caption chunks

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([rulebookId])
  @@index([ruleId])
  @@index([sectionId])
}

model Table {
  id           String    @id @default(cuid())
  rulebookId   String
  rulebook     Rulebook  @relation(fields: [rulebookId], references: [id], onDelete: Cascade)

  sectionId    String?
  section      Section?  @relation(fields: [sectionId], references: [id], onDelete: SetNull)

  ruleId       String?
  rule         Rule?     @relation(fields: [ruleId], references: [id], onDelete: SetNull)

  page         Int?
  boundingBox  String?   // JSON as String for SQLite

  jsonData     String?   // structured rows + headers as JSON string
  markdown     String?   // LLM-friendly representation

  chunks       Chunk[]

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([rulebookId])
  @@index([ruleId])
  @@index([sectionId])
}

model Chunk {
  id           String    @id @default(cuid())
  rulebookId   String
  rulebook     Rulebook  @relation(fields: [rulebookId], references: [id], onDelete: Cascade)

  sectionId    String?
  section      Section?  @relation(fields: [sectionId], references: [id], onDelete: SetNull)

  ruleId       String?
  rule         Rule?     @relation(fields: [ruleId], references: [id], onDelete: SetNull)

  diagramId    String?
  diagram      Diagram?  @relation(fields: [diagramId], references: [id], onDelete: SetNull)

  tableId      String?
  table        Table?    @relation(fields: [tableId], references: [id], onDelete: SetNull)

  type         String    // "NARRATIVE" | "RULE" | "TABLE" | "DIAGRAM_CAPTION"
  pageStart    Int?
  pageEnd      Int?
  text         String
  tokenCount   Int?

  // Either store embedding in DB or reference external vector store
  embedding    Bytes?    // SQLite supports Bytes for binary data

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([rulebookId])
  @@index([ruleId])
  @@index([diagramId])
  @@index([tableId])
  @@index([type])
  @@index([sectionId])
}
